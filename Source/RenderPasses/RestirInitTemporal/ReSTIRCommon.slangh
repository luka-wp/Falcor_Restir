#pragma once
#include "Utils/Math/MathConstants.slangh"

import Scene.Raytracing;
import Scene.Intersection;
import Utils.Math.MathHelpers;
import Utils.Geometry.GeometryHelpers;
import Utils.Sampling.SampleGenerator;
import Rendering.Lights.LightHelpers;
import Utils.Color.ColorHelpers;

/* ================ *
 * ==== Common ==== *
 * ==== Begin ===== *
 * ================ */

struct DIReservoir
{
    int lightIndex;
    float weightSum;
    int M;
    float W;

    static DIReservoir makeEmpty()
    {
        DIReservoir reservoir;
        reservoir.lightIndex = -1;
        reservoir.weightSum = 0.f;
        reservoir.M = 0;
        reservoir.W = 0.f;
        return reservoir;
    }

    [mutating]
    void update(int inLightIndex, float weight, float random)
    {
        weightSum += weight;
        M += 1;
        if (random * weightSum < weight)
        {
            lightIndex = inLightIndex;
        }
    }

    [mutating]
    void merge(DIReservoir reservoir, float weight, float random)
    {
        int currentM = M;
        update(reservoir.lightIndex, weight * reservoir.W * reservoir.M, random);
        M = currentM + reservoir.M;
    }

    [mutating]
    void finalize(float pHat)
    {
        if (pHat == 0.f)
        {
            W = 0.f;
        }
        else
        {
            W = weightSum / (pHat * M);
        }
    }
};

struct GIReservoir
{
    float3 visiblePoint;
    float3 visibleNormal;

    float3 samplePoint;
    float3 sampleNormal;
    float3 sampleRadiance;

    float weightSum;
    uint M;
    uint age;

    static GIReservoir makeReservoir(
        float3 inVisiblePoint,
        float3 inVisibleNormal,
        float3 inSamplePoint,
        float3 inSampleNormal,
        float3 inSampleRadiance,
        float inSamplePdf
    )
    {
        GIReservoir reservoir;
        reservoir.visiblePoint = inVisiblePoint;
        reservoir.visibleNormal = inVisibleNormal;
        reservoir.samplePoint = inSamplePoint;
        reservoir.sampleNormal = inSampleNormal;
        reservoir.sampleRadiance = inSampleRadiance;
        reservoir.weightSum = inSamplePdf > 0.f ? 1.f / inSamplePdf : 0.f;
        reservoir.M = 1;
        reservoir.age = 0;
        return reservoir;
    }

    static GIReservoir makeEmpty()
    {
        GIReservoir reservoir;
        reservoir.visiblePoint = float3(0.f);
        reservoir.visibleNormal = float3(0.f);
        reservoir.samplePoint = float3(0.f);
        reservoir.sampleNormal = float3(0.f);
        reservoir.sampleRadiance = float3(0.f);
        reservoir.weightSum = 0.f;
        reservoir.M = 0;
        reservoir.age = 0;
        return reservoir;
    }

    bool isValid() { return M != 0; }

    [mutating]
    bool merge(GIReservoir reservoir, float targetPdf, float random)
    {
        float risWeight = targetPdf * reservoir.weightSum * reservoir.M;
        M += reservoir.M;
        weightSum += risWeight;
        bool selectSample = (random * weightSum <= risWeight);
        if (selectSample)
        {
            samplePoint = reservoir.samplePoint;
            sampleNormal = reservoir.sampleNormal;
            sampleRadiance = reservoir.sampleRadiance;
            age = reservoir.age;
        }

        return selectSample;
    }

    [mutating]
    void finalize(float numerator, float denominator) { weightSum = (denominator == 0.f) ? 0.f : (weightSum * numerator) / denominator; }
};

Texture2D<PackedHitInfo> gVBuffer;
Texture2D<float4> gViewW;

#define is_valid(name) (is_valid_##name != 0)

float3 getPrimaryRayDir(uint2 launchIndex, uint2 launchDim)
{
    if (is_valid(gViewW))
    {
        return -gViewW[launchIndex].xyz;
    }
    return gScene.camera.computeRayPinhole(launchIndex, launchDim).dir;
}

void getShadingDataAndMaterial(out ShadingData shadingData, out IMaterialInstance materialInstance, uint2 pixel, uint2 frameDim)
{
    float3 rayDir = getPrimaryRayDir(pixel, frameDim);
    let lod = ExplicitLodTextureSampler(0.f);
    { // Inlined loadShadingData
        const HitInfo hit = HitInfo(gVBuffer[pixel]);
        VertexData v = {};
        uint materialID = {};
        if (hit.getType() == HitType::Triangle)
        {
            const TriangleHit triangleHit = hit.getTriangleHit();
            v = gScene.getVertexData(triangleHit);
            materialID = gScene.getMaterialID(triangleHit.instanceID);
        }

        shadingData = gScene.materials.prepareShadingData(v, materialID, -rayDir, lod);
    }

    { // Material instance
        materialInstance = gScene.materials.getMaterialInstance(shadingData, lod);
    }
}

uint getPixelIndex(uint2 pixel, uint2 frame)
{
    return pixel.x + pixel.y * frame.x;
}

float getTargetPdfForSurface(ShadingData shadingData, IMaterialInstance materialInstance, float3 samplePosition, float3 sampleRadiance)
{
    float3 L = normalize(samplePosition - shadingData.posW);
    float NdotL = saturate(dot(L, shadingData.faceN));
    BSDFProperties bsdf = materialInstance.getProperties(shadingData);
    // float3 reflectedRadiance = sampleRadiance * bsdf.diffuseReflectionAlbedo * NdotL;
    float3 reflectedRadiance = NdotL * sampleRadiance * (bsdf.diffuseReflectionAlbedo + bsdf.specularReflectionAlbedo);
    return luminance(reflectedRadiance);
    // return luminance(sampleRadiance);
    // SampleGenerator dummySG = SampleGeneraotr(uint2(1, 1), 1337);
    // return materialInstance.eval(shadingData, L)
}

void calculatePartialJacobian(
    const float3 reciverPos,
    const float3 samplePos,
    const float3 sampleNormal,
    out float distanceToSurface,
    out float cosineEmissionAngle
)
{
    float3 vec = reciverPos - samplePos;
    distanceToSurface = length(vec);
    cosineEmissionAngle = saturate(dot(sampleNormal, vec / distanceToSurface));
}

float calculateJacobian(float3 reciverPos, float3 neighborReciverPos, GIReservoir neighborReservoir)
{
    float originalDistance, originalCosine;
    float newDistance, newCosine;
    calculatePartialJacobian(reciverPos, neighborReservoir.samplePoint, neighborReservoir.sampleNormal, newDistance, newCosine);
    calculatePartialJacobian(
        neighborReciverPos, neighborReservoir.samplePoint, neighborReservoir.sampleNormal, originalDistance, originalCosine
    );

    float denom = (originalCosine * newDistance * newDistance);
    float jacobian = denom != 0.f ? (newCosine * originalDistance * originalDistance) / denom : 0.f;

    if (isinf(jacobian) || isnan(jacobian))
    {
        jacobian = 0.f;
    }
    return jacobian;
}

bool validateSampleWithJacobian(inout float jacobian)
{
    if (jacobian > 10.f || jacobian < 0.1f)
    {
        return false;
    }

    jacobian = clamp(jacobian, 1.f / 3.f, 1.f);
    return true;
}

bool validateGeometricSimilarity(float3 positionA, float3 normalA, float3 positionB, float3 normalB, float4x4 viewProj)
{
    const float NdotN = dot(normalA, normalB);
    if (NdotN < 0.f)
    {
        return false;
    }
    const float phi = acos(NdotN);
    if (phi > (25.f / 180.f * M_PI))
    {
        return false;
    }
    float4 a = mul(viewProj, float4(positionA, 1.f));
    float4 b = mul(viewProj, float4(positionB, 1.f));
    a.xyz /= a.w;
    b.xyz /= b.w;
    if (abs(a.z - b.z) > 0.05f)
    {
        return false;
    }

    return true;
}

struct ShadowRayData
{
    bool visible;
};

bool traceShadowRay(float3 origin, float3 dir, float distance)
{
    RayDesc ray;
    ray.Origin = origin;
    ray.Direction = dir;
    ray.TMin = 0.f;
    ray.TMax = distance;

    ShadowRayData rayData;
    rayData.visible = false; // Set to true by miss shader if ray is not terminated before
    TraceRay(
        gScene.rtAccel,
        RAY_FLAG_ACCEPT_FIRST_HIT_AND_END_SEARCH,
        0xff /* instanceInclusionMask */,
        0 /* hitIdx */,
        rayTypeCount,
        0 /* missIdx */,
        ray,
        rayData
    );

    return rayData.visible;
}

float3 evalDirectAnalytic(
    const ShadingData sd,
    const IMaterialInstance mi,
    bool visibilityTest,
    inout SampleGenerator sg,
    inout int lightIdx
)
{
    const uint lightCount = gScene.getLightCount();
    if (lightCount == 0)
        return float3(0.f);

    // Pick one of the analytic light sources randomly with equal probability.
    const uint lightIndex = lightIdx != -1 ? lightIdx : min(uint(sampleNext1D(sg) * lightCount), lightCount - 1);
    float invPdf = lightCount; // Light selection pdf = 1.0 / lightCount.

    // Sample local light source.
    AnalyticLightSample ls;
    if (!sampleLight(sd.posW, gScene.getLight(lightIndex), sg, ls))
        return float3(0.f);

    // Reject sample if not in the hemisphere of a BSDF lobe.
    const uint lobeTypes = mi.getLobeTypes(sd);
    const bool hasReflection = lobeTypes & uint(LobeType::Reflection);
    const bool hasTransmission = lobeTypes & uint(LobeType::Transmission);
    float NdotL = dot(sd.getOrientedFaceNormal(), ls.dir);
    if ((NdotL <= kMinCosTheta && !hasTransmission) || (NdotL >= -kMinCosTheta && !hasReflection))
        return float3(0.f);

    // Get origin with offset applied in direction of the geometry normal to avoid self-intersection.
    const float3 origin = computeRayOrigin(sd.posW, dot(sd.faceN, ls.dir) >= 0.f ? sd.faceN : -sd.faceN);

    // Test visibility by tracing a shadow ray.
    if (visibilityTest)
    {
        bool V = traceShadowRay(origin, ls.dir, ls.distance);
        if (!V)
            return float3(0.f);
    }

    // Evaluate contribution.
    lightIdx = lightIndex;
    return mi.eval(sd, ls.dir, sg) * ls.Li * invPdf;
}

[shader("miss")]
void shadowMiss(inout ShadowRayData rayData)
{
    rayData.visible = true;
}

[shader("anyhit")]
void shadowAnyHit(inout ShadowRayData rayData, BuiltInTriangleIntersectionAttributes attribs)
{
    GeometryInstanceID instanceID = getGeometryInstanceID();
    VertexData v = getVertexData(instanceID, PrimitiveIndex(), attribs);
    const uint materialID = gScene.getMaterialID(instanceID);
    if (gScene.materials.alphaTest(v, materialID, 0.f))
        IgnoreHit();
}

/* ================ *
 * ==== Common ==== *
 * ==== End ===== *
 * ================ */